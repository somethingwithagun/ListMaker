#include "AppLogic.h"
std::ifstream input;
std::ofstream output;

const std::string LogFileName = "ListMakerLog.log";
const std::string LogDirName = "Logs";
std::string OutFileName;
std::string buffer;
std::string SortType;
std::string OrderType;
std::string *pO;
std::string *pI;

char mark = ' ';

int Counter = 0;
int AmountOfItems;

int Magic(std::string InFilePath, std::string aOrderType, std::string aSortType, std::string aname,
          std::string aOutFilePath)
{
    std::string ItemsMassive[1001];
    std::string OrderedMassive[1001];

    pO = OrderedMassive;
    pI = ItemsMassive;

    CheckIsPrev(aOrderType, aSortType);
    Numerate(InFilePath);
    Order();
    Sort(aSortType);
    Name(aname);
    Print(aOutFilePath);
    Log();
    delete pO, pI;
    return 0;
}
int Numerate(std::string InFilePath)
{
    input.open(InFilePath); // the name of input file
    if (!input.is_open())
        return -1;
    while (getline(input, buffer)) // If string is not empty
    {
        std::string FormattedString = "";
        bool StopSymFound = false;
        int s;
        if (buffer != "")
        {
            for (int i = 0; i < buffer.size(); i++)
            {
                if (int(buffer[i]) >= -64 && int(buffer[i]) <= 122)
                {
                    if (buffer[i] < '0' || buffer[i] > '9')
                    {
                        if (int(buffer[i]) < 41 || int(buffer[i]) > 46)
                        {
                            StopSymFound = true;
                            if (buffer[i] == ' ')
                                i++;
                            s = i;
                            break;
                        }
                    }
                }
                if (StopSymFound)
                    break;
            }
            if (StopSymFound)
            {
                for (int j = s; j < buffer.size(); j++)
                {
                    FormattedString += buffer[j];
                }
            }
            for (int i = 1; i <= Counter; i++) // check if there are any similar items
            {
                if (pI[i] == FormattedString)
                {
                    FormattedString.clear();
                    buffer = "bad";
                }
            }
            if (FormattedString != "")
                buffer = FormattedString;
            else
                buffer = "bad";
        }
        else
            buffer = "bad";

        if (buffer == "bad")
            continue;
        else
        {
            Counter++;
            pI[Counter] = buffer; // filling massive
        }
    }
    AmountOfItems = Counter;
    input.close();
    if (AmountOfItems < 1)
    {
        return 1;
    }
    return 1;
}
void CheckIsPrev(std::string aOrderType, std::string aSortType)
{
    if (aOrderType == "prev")
        OrderType = SetPreviousValue("mark");
    else
        OrderType = aOrderType;
    if (aSortType == "prev")
        SortType = SetPreviousValue("sort");
    else
        SortType = aSortType;
}
void Order()
{
    if (OrderType == "none")
        mark = ' ';
    else if (OrderType == "brackets")
        mark = ')';
    else if (OrderType == "dots")
        mark = '.';
    if (mark == ' ')
        for (Counter = 1; Counter <= AmountOfItems; Counter++)
            if (pI[Counter] != "")
                pO[Counter] = pI[Counter];
            else
                continue;
    else
        for (Counter = 1; Counter <= AmountOfItems; Counter++)
            if (pI[Counter] != "")
                pO[Counter] = std::to_string(Counter) + mark + ' ' + pI[Counter];
            else
                continue;
}
void Sort(std::string aSortType)
{
    if (aSortType == "reverse")
    {
        SortType = "reverse";
        for (int i = 0; i <= AmountOfItems / 2; i++)
        {
            std::string t = pO[i];
            pO[i] = pO[AmountOfItems - i + 1];
            pO[AmountOfItems - i + 1] = t;
        }
    }
    else if (aSortType == "none")
    {
        SortType = "none";
    }
}
void Name(std::string aname)
{
    OutFileName = aname;
    std::string OutExtension = AnExt(OutFileName);
    if (OutExtension == "none")
    {
        OutExtension = ".txt";
        OutFileName += OutExtension;
    }
}
void Print(std::string aOutFilePath)
{
    output.open(aOutFilePath + '/' + OutFileName);
    for (Counter = 1; Counter <= AmountOfItems; Counter++)
    {
        if (pO[Counter] != "")
            output << pO[Counter] << std::endl;
    }
    output.close();
}
void Log()
{
    std::ofstream Log;
    if (!std::filesystem::exists(LogDirName))
        std::filesystem::create_directory(LogDirName);
    Log.open(LogDirName + '/' + LogFileName);
    Log << "Do not edit this file" << std::endl;
    Log << "The last time list was made: " << currentDateTime() << std::endl;
    Log << "@title: " << '<' << OutFileName << '>' << std::endl;
    Log << "@sort: " << '<' << SortType << '>' << std::endl;
    Log << "@mark: " << '<' << OrderType << '>' << std::endl;
    Log.close();
}
bool IsKeyWord(std::string KeyWord)
{
    if (KeyWord == "title" || KeyWord == "sort" || KeyWord == "mark")
        return true;
    else
        return false;
}
std::string SetPreviousValue(std::string type)
{
    std::ifstream Log;
    Log.open(LogDirName + '/' + LogFileName);
    std::string buffer;
    std::string VarValue;
    std::string Keyword;
    while (getline(Log, buffer))
    {
        Keyword = "";
        for (int i = 0; i < buffer.size(); i++)
        {
            if (buffer[i] == '@')
            {
                int j = i + 1;
                while (buffer[j] != ':')
                {
                    if (buffer[j] != ' ')
                        Keyword += buffer[j];
                    if (j > 15)
                        return "none";
                    j++;
                }
                if (IsKeyWord(Keyword))
                {
                    if (Keyword != type)
                        break;
                    int Value = j;
                    VarValue = "";
                    while (buffer[Value] != '<')
                    {
                        Value++;
                        if (Value > 100)
                            return "none";
                    }
                    Value++;
                    while (buffer[Value] != '>')
                    {
                        if (buffer[Value] != ' ')
                            VarValue += buffer[Value];
                        if (Value > 100)
                            return "none";
                        Value++;
                    }
                }
                else
                    return "false";
                break;
            }
        }
    }
    if (VarValue.size() < 1)
    {
        return "false";
    }
    if (VarValue.size() < 1)
    {
        return "false";
    }
    Log.close();
    return VarValue;
}
std::string AnExt(std::string x)
{
    int i = 0;
    std::string ext = "";
    while (x[i] != '.')
    {
        i++;
        if (i > x.size())
        {
            return "none";
        }
    }
    while (i != x.size())
    {
        ext += x[i];
        i++;
    }
    return ext;
}
const std::string currentDateTime()
{
    time_t now = time(0);
    struct tm tstruct;
    char buf[80];
    tstruct = *localtime(&now);
    strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

    return buf;
}